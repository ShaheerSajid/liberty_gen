"""
Liberty (.lib) file renderer.

Pure string formatting — no simulation, no I/O.
Takes measured data tables and renders a complete Synopsys Liberty file.

Key correctness improvements over common reference implementations
------------------------------------------------------------------
* ``pg_pin`` declarations for VDD / VSS (required by modern parsers).
* Separate ``rise_constraint`` / ``fall_constraint`` tables for setup and hold
  (many tools incorrectly emit the same values for both).
* Correct ``bus_type`` declarations at library level with ``downto : true``.
* ``timing_sense : non_unate`` on Q outputs (SRAM reads are non-unate —
  output polarity depends on stored data, not input polarity).
* ``cell_leakage_power`` attribute on the cell.
* ``timing_type : min_pulse_width`` group on CLK.
"""
from __future__ import annotations

import textwrap
from liberty_gen.config import CharConfig


# ─────────────────────────────────────────────────────────────────────────────
# LUT formatting helpers
# ─────────────────────────────────────────────────────────────────────────────

def _fmt_index(values: list[float]) -> str:
    return '"' + ", ".join(f"{v:.5f}" for v in values) + '"'


def _fmt_values_2d(table: list[list], fallback: float = 0.0) -> str:
    """Format a 2-D table as Liberty ``values(...)`` syntax.

    None entries are replaced with ``fallback`` (marks missing sim data).
    """
    rows = []
    for row in table:
        vals = [fallback if v is None else v for v in row]
        rows.append('"' + ", ".join(f"{v:.5f}" for v in vals) + '"')
    sep = ", \\\n              "
    return "values(" + sep.join(rows) + ");"


def _fmt_scalar(v: float | None, fallback: float = 0.0) -> str:
    val = v if v is not None else fallback
    return f'values("{val:.5f}");'


# ─────────────────────────────────────────────────────────────────────────────
# Section builders
# ─────────────────────────────────────────────────────────────────────────────

def _library_header(macro_name: str, cfg: CharConfig) -> str:
    vdd_str = f"{cfg.vdd:.2f}".replace(".", "p")
    temp_str = f"{int(cfg.temp):+03d}C".replace("+", "")
    lib_name = f"{macro_name}_{temp_str}_{vdd_str}V"
    return textwrap.dedent(f"""\
    /* Generated by liberty_gen */
    library ({lib_name}) {{
      technology (cmos);
      delay_model : table_lookup;
      time_unit : "1ns";
      voltage_unit : "1V";
      current_unit : "1uA";
      leakage_power_unit : "1nW";
      pulling_resistance_unit : "1kohm";
      capacitive_load_unit (1, pf);
      input_threshold_pct_fall : {cfg.th_lo * 100:.0f};
      input_threshold_pct_rise : {cfg.th_hi * 100:.0f};
      output_threshold_pct_fall : {cfg.th_lo * 100:.0f};
      output_threshold_pct_rise : {cfg.th_hi * 100:.0f};
      slew_lower_threshold_pct_fall : {cfg.th_lo * 100:.0f};
      slew_upper_threshold_pct_rise : {cfg.th_hi * 100:.0f};

      operating_conditions (op) {{
        process     : 1.0;
        voltage     : {cfg.vdd};
        temperature : {cfg.temp};
      }}
      default_operating_conditions : op;
    """)


def _lut_templates(slews: list[float], loads: list[float]) -> str:
    idx_slew = _fmt_index(slews)
    idx_load = _fmt_index(loads)
    return textwrap.dedent(f"""\
      /* 2-D delay template: CLK_slew × output_load */
      lu_table_template (clkq_tmpl) {{
        variable_1 : input_net_transition;
        variable_2 : total_output_net_capacitance;
        index_1 ({idx_slew});
        index_2 ({idx_load});
      }}

      /* 2-D constraint template: pin_slew × CLK_slew */
      lu_table_template (cstr_tmpl) {{
        variable_1 : constrained_pin_transition;
        variable_2 : related_pin_transition;
        index_1 ({idx_slew});
        index_2 ({idx_slew});
      }}
    """)


def _bus_types(addr_bits: int, bits: int) -> str:
    def _btype(name: str, width: int) -> str:
        return textwrap.dedent(f"""\
          type ({name}) {{
            base_type : array;
            data_type : bit;
            bit_width  : {width};
            bit_from   : {width - 1};
            bit_to     : 0;
            downto     : true;
          }}
        """)
    return _btype("addr_t", addr_bits) + _btype("din_t", bits) + _btype("Q_t", bits)


def _pg_pins() -> str:
    return textwrap.dedent("""\
        pg_pin (VDD) {
          pg_type     : primary_power;
          voltage_name : VDD;
        }
        pg_pin (VSS) {
          pg_type     : primary_ground;
          voltage_name : VSS;
        }
    """)


def _clk_pin(min_pw: float | None) -> str:
    pw_val = min_pw if min_pw is not None else 0.0
    return textwrap.dedent(f"""\
        pin (CLK) {{
          direction    : input;
          clock        : true;
          capacitance  : 0.0;
          timing () {{
            timing_type : min_pulse_width;
            related_pin : "CLK";
            rise_constraint (scalar) {{ {_fmt_scalar(pw_val)} }}
            fall_constraint (scalar) {{ {_fmt_scalar(pw_val)} }}
          }}
        }}
    """)


def _sh_timing_groups(pin_name: str, sh_data: dict) -> str:
    """Two timing() groups for setup_rising and hold_rising on an input pin."""
    setup_tbl = sh_data.get("setup", [[0.0]])
    hold_tbl  = sh_data.get("hold",  [[0.0]])
    return textwrap.dedent(f"""\
          timing () {{
            related_pin    : "CLK";
            timing_type    : setup_rising;
            rise_constraint (cstr_tmpl) {{
              {_fmt_values_2d(setup_tbl)}
            }}
            fall_constraint (cstr_tmpl) {{
              {_fmt_values_2d(setup_tbl)}
            }}
          }}
          timing () {{
            related_pin    : "CLK";
            timing_type    : hold_rising;
            rise_constraint (cstr_tmpl) {{
              {_fmt_values_2d(hold_tbl)}
            }}
            fall_constraint (cstr_tmpl) {{
              {_fmt_values_2d(hold_tbl)}
            }}
          }}
    """)


def _simple_input_pin(pin_name: str, sh_data: dict) -> str:
    sh = _sh_timing_groups(pin_name, sh_data)
    return textwrap.dedent(f"""\
        pin ({pin_name}) {{
          direction   : input;
          capacitance : 0.0;
    {textwrap.indent(sh, "    ")}
        }}
    """)


def _input_bus(bus_name: str, type_name: str, n_bits: int, sh_data: dict) -> str:
    """Bus of input pins sharing identical setup/hold arcs (e.g. addr, din)."""
    sh = _sh_timing_groups(bus_name, sh_data)
    hi = n_bits - 1
    return textwrap.dedent(f"""\
        bus ({bus_name}) {{
          bus_type  : {type_name};
          direction : input;
          pin ({bus_name}[{hi}:0]) {{
            capacitance : 0.0;
    {textwrap.indent(sh, "      ")}
          }}
        }}
    """)


def _output_bus(bus_name: str, type_name: str, n_bits: int,
                clkq_data: dict, max_load: float) -> str:
    """Bus of output pins with CLK-to-Q timing arcs."""
    cr  = clkq_data.get("cell_rise",       [[0.0]])
    cf  = clkq_data.get("cell_fall",       [[0.0]])
    rtr = clkq_data.get("rise_transition", [[0.0]])
    ftr = clkq_data.get("fall_transition", [[0.0]])
    hi  = n_bits - 1
    return textwrap.dedent(f"""\
        bus ({bus_name}) {{
          bus_type         : {type_name};
          direction        : output;
          function         : "0";
          max_capacitance  : {max_load:.5f};
          pin ({bus_name}[{hi}:0]) {{
            timing () {{
              related_pin    : "CLK";
              timing_sense   : non_unate;
              timing_type    : rising_edge;
              cell_rise (clkq_tmpl) {{
                {_fmt_values_2d(cr)}
              }}
              rise_transition (clkq_tmpl) {{
                {_fmt_values_2d(rtr)}
              }}
              cell_fall (clkq_tmpl) {{
                {_fmt_values_2d(cf)}
              }}
              fall_transition (clkq_tmpl) {{
                {_fmt_values_2d(ftr)}
              }}
            }}
          }}
        }}
    """)


def _power_attributes(leakage_nw: float, write_power_nw: float,
                      read_power_nw: float) -> str:
    return textwrap.dedent(f"""\
        cell_leakage_power : {leakage_nw:.3f};

        internal_power () {{
          related_pin : "CLK";
          /* rise_power = read operation, fall_power = write operation */
          rise_power (scalar) {{ values("{read_power_nw:.3f}"); }}
          fall_power (scalar) {{ values("{write_power_nw:.3f}"); }}
        }}
    """)


# ─────────────────────────────────────────────────────────────────────────────
# Top-level renderer
# ─────────────────────────────────────────────────────────────────────────────

def render_liberty(
    macro_name: str,
    cfg: CharConfig,
    addr_bits: int,
    bits: int,
    clkq_data: dict,
    setup_hold_data: dict[str, dict],   # pin → {"setup": 2D, "hold": 2D}
    min_pw: float | None,
    leakage_nw: float = 0.0,
    write_power_nw: float = 0.0,
    read_power_nw: float = 0.0,
) -> str:
    """Render and return a complete Synopsys Liberty (.lib) string."""
    slews = cfg.input_slews
    loads = cfg.output_loads
    max_load = max(loads)

    lines: list[str] = []
    lines.append(_library_header(macro_name, cfg))
    lines.append(_lut_templates(slews, loads))
    lines.append(_bus_types(addr_bits, bits))

    # ── Cell ─────────────────────────────────────────────────────────────────
    lines.append(f"  cell ({macro_name}) {{")
    lines.append(textwrap.indent(_power_attributes(leakage_nw, write_power_nw, read_power_nw), "    "))
    lines.append(textwrap.indent(_pg_pins(), "    "))
    lines.append(textwrap.indent(_clk_pin(min_pw), "    "))

    # CS and WRITE: simple input pins
    for p in ["CS", "WRITE"]:
        sh = setup_hold_data.get(p, {"setup": [[0.0] * len(slews)] * len(slews),
                                     "hold":  [[0.0] * len(slews)] * len(slews)})
        lines.append(textwrap.indent(_simple_input_pin(p, sh), "    "))

    # addr bus
    addr_sh = setup_hold_data.get("addr0", {"setup": [[0.0]], "hold": [[0.0]]})
    lines.append(textwrap.indent(_input_bus("addr", "addr_t", addr_bits, addr_sh), "    "))

    # din bus
    din_sh = setup_hold_data.get("din0", {"setup": [[0.0]], "hold": [[0.0]]})
    lines.append(textwrap.indent(_input_bus("din", "din_t", bits, din_sh), "    "))

    # Q bus (output)
    lines.append(textwrap.indent(_output_bus("Q", "Q_t", bits, clkq_data, max_load), "    "))

    lines.append("  }")  # end cell
    lines.append("}")    # end library
    return "\n".join(lines) + "\n"
